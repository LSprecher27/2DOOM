<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOOM 2D: FINAL VERSION</title>
    <style>
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background-color: #050505; overflow: hidden; 
            font-family: 'Courier New', Courier, monospace;
        }
        canvas { display: block; background-color: #0a0a0a; cursor: crosshair; }
        
        #hud { 
            position: absolute; top: 0; left: 0; width: 100%;
            display: flex; justify-content: space-around; padding: 15px; 
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 100%);
            font-size: 22px; font-weight: bold; z-index: 100; pointer-events: none;
        }
        .stat { color: #fff; text-shadow: 0 0 5px #ff0000; }
        .label { color: #888; margin-right: 5px; }

        /* WATERMARK STYLE */
        #watermark {
            position: absolute; bottom: 10px; right: 15px;
            color: rgba(255, 255, 255, 0.3); font-size: 14px;
            z-index: 100; pointer-events: none; text-decoration: none;
        }
        
        #radio-container { position: absolute; top: 70px; right: 20px; background: rgba(20, 20, 20, 0.9); border: 2px solid #ff4444; padding: 12px; color: white; font-size: 12px; z-index: 101; }
        .radio-btn { background: #ff4444; color: black; border: none; padding: 5px; margin-top: 10px; cursor: pointer; font-weight: bold; width: 100%; text-transform: uppercase; }
        
        #now-playing { 
            position: absolute; bottom: 30px; left: 0; transform: translateX(-105%); 
            width: max-content; padding: 15px 30px; background: rgba(255, 68, 68, 0.95); 
            color: black; font-weight: bold; border-right: 10px solid #fff; 
            transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1); z-index: 200; 
            text-transform: uppercase; white-space: nowrap; pointer-events: none;
        }
        #now-playing.show { transform: translateX(0); }
        #damage-flash { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 0, 0, 0.4); pointer-events: none; display: none; z-index: 1000; }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 500;
        }
        .menu-title { font-size: 64px; color: #ff0000; text-shadow: 0 0 15px #ff0000; margin-bottom: 30px; }
        .menu-btn { 
            background: #ff4444; color: black; border: none; padding: 20px 50px; 
            font-size: 24px; font-weight: bold; cursor: pointer; text-transform: uppercase;
        }
    </style>
</head>
<body>

    <div id="damage-flash"></div>
    <div id="now-playing">NOW PLAYING: <span id="track-title">NONE</span></div>
    
    <div id="watermark">https://github.com/LSprecher27</div>

    <div id="start-menu" class="overlay">
        <div class="menu-title">DOOM 2D</div>
        <button class="menu-btn" onclick="startGame()">Start Game</button>
    </div>

    <div id="pause-menu" class="overlay" style="display: none;">
        <div class="menu-title">PAUSED</div>
        <button class="menu-btn" onclick="togglePause()">Resume</button>
    </div>

    <div id="radio-container">
        <div style="font-weight:bold; color:#ff4444; border-bottom:1px solid #444; margin-bottom:8px;">UAC RADIO</div>
        <label><input type="radio" name="track" value="off" checked> Mute</label><br>
        <label><input type="radio" name="track" value="radio"> Auto-Play</label><br>
        <button class="radio-btn" id="skip-btn">Skip Track Â»</button>
    </div>

    <div id="hud">
        <div><span class="label">LVL:</span><span id="level-num" class="stat">1</span></div>
        <div><span class="label">HP:</span><span id="health" class="stat">100</span></div>
        <div><span class="label">AMMO:</span><span id="ammo" class="stat">30</span></div>
        <div><span class="label">KILLS:</span><span id="kills" class="stat">0</span></div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const assets = {
    player: new Image(), enemy: new Image(),
    ammo: new Image(), hp: new Image(), berserk: new Image()
};
assets.player.src = 'images/player.png';
assets.enemy.src = 'images/enemy.png';
assets.ammo.src = 'images/ammo.png';
assets.hp.src = 'images/hp.png';
assets.berserk.src = 'images/berserk.png';

const bgMusic = new Audio();
const trackNames = { 
    1: "Hot Dog - Limp Bizkit", 2: "Chop Suey! - SOAD", 3: "Break Stuff - Limp Bizkit", 
    4: "I Hate Everything - 3DG", 5: "Down with Sickness - Disturbed", 
    6: "Hammerhead - Offspring", 7: "Somewhere I Belong - Linkin Park",
    8: "Come Out Swinging - The Offspring" 
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let player = { x: 150, y: 150, health: 100, ammo: 30, lastShot: 0, berserk: 0 };
let enemies = [], projectiles = [], bloodSplats = [], pickups = [], walls = [], shells = [], floorDetails = [];
let keys = {}, mousePos = {x:0, y:0}, gameStarted = false, isPaused = false, currentLevel = 1, killCount = 0, screenShake = 0, muzzleFlash = 0, gameTicks = 0;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if(gameStarted) spawnLevel();
}
window.addEventListener('resize', resize);
resize();

function isWall(x, y) { return walls.some(w => x >= w.x && x < w.x+50 && y >= w.y && y < w.y+50); }

function spawnLevel() {
    walls = []; floorDetails = []; enemies = []; pickups = []; shells = [];
    const tw = Math.ceil(canvas.width / 50), th = Math.ceil(canvas.height / 50);

    for(let x=0; x<tw; x++) {
        for(let y=0; y<th; y++) {
            if(Math.random() > 0.85) floorDetails.push({x: x*50, y: y*50});
        }
    }
    for(let i=0; i<tw; i++) { walls.push({x:i*50, y:0}, {x:i*50, y:(th-1)*50}); }
    for(let i=0; i<th; i++) { walls.push({x:0, y:i*50}, {x:(tw-1)*50, y:i*50}); }
    
    for(let i=0; i<8; i++) {
        let cx = Math.floor(Math.random()*(tw-6))+3, cy = Math.floor(Math.random()*(th-6))+3;
        walls.push({x:cx*50, y:cy*50}, {x:(cx+1)*50, y:cy*50}, {x:cx*50, y:(cy+1)*50}, {x:(cx+1)*50, y:(cy+1)*50});
    }

    // SAFE PLAYER SPAWN
    let px, py;
    do { px = Math.random() * (canvas.width - 200) + 100; py = Math.random() * (canvas.height - 200) + 100; } while (isWall(px, py));
    player.x = px; player.y = py;

    // SAFE ENEMY SPAWN
    for(let i=0; i<5+currentLevel; i++) {
        let ex, ey;
        do { ex = Math.random() * (canvas.width - 200) + 100; ey = Math.random() * (canvas.height - 200) + 100;
        } while (isWall(ex, ey) || Math.hypot(ex - player.x, ey - player.y) < 250);
        enemies.push({x: ex, y: ey, hp: 60});
    }

    ['ammo', 'hp', 'berserk'].forEach(type => {
        let pickX, pickY;
        do { pickX = Math.random() * (canvas.width - 200) + 100; pickY = Math.random() * (canvas.height - 200) + 100; } while (isWall(pickX, pickY));
        pickups.push({x: pickX, y: pickY, type: type});
    });
}

function drawFlippedSprite(img, x, y, targetX, targetY, size, fallbackColor, isPickup = false) {
    const angle = Math.atan2(targetY - y, targetX - x);
    const flip = targetX < x;
    ctx.save();
    ctx.translate(x, y);
    if (isPickup) { ctx.scale(Math.sin(gameTicks * 0.08), 1); } 
    else {
        if (flip) { ctx.scale(-1, 1); ctx.rotate(-angle + Math.PI); } 
        else { ctx.rotate(angle); }
    }
    if (img.complete && img.naturalWidth !== 0) ctx.drawImage(img, -size/2, -size/2, size, size);
    else { ctx.fillStyle = fallbackColor; ctx.fillRect(-size/2, -size/2, size, size); }
    ctx.restore();
}

function startGame() {
    document.getElementById('start-menu').style.display = 'none';
    gameStarted = true;
    spawnLevel();
    loop();
}

function togglePause() {
    if(!gameStarted) return;
    isPaused = !isPaused;
    document.getElementById('pause-menu').style.display = isPaused ? 'flex' : 'none';
    if(!isPaused) loop();
}

function loop() {
    if(!gameStarted || isPaused) return;
    gameTicks++;
    ctx.save();
    if(screenShake > 0) { ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake); screenShake *= 0.85; }
    
    ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0,0,canvas.width,canvas.height);
    floorDetails.forEach(d => { ctx.fillStyle = '#0f0f0f'; ctx.fillRect(d.x, d.y, 48, 48); });

    ctx.fillStyle = '#aa8800'; shells.forEach(s => { ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(s.r); ctx.fillRect(-2,-1,4,2); ctx.restore(); });
    bloodSplats.forEach(b => { ctx.fillStyle=b.c; ctx.beginPath(); ctx.arc(b.x, b.y, b.s, 0, Math.PI*2); ctx.fill(); });

    walls.forEach(w => {
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(w.x, w.y, 50, 50);
        ctx.strokeStyle = '#333'; ctx.strokeRect(w.x+2, w.y+2, 46, 46);
    });

    let speed = player.berserk > 0 ? 6.5 : 4.0;
    let mx = 0, my = 0;
    if(keys['w']) my -= speed; if(keys['s']) my += speed;
    if(keys['a']) mx -= speed; if(keys['d']) mx += speed;
    if(!isWall(player.x + mx, player.y)) player.x += mx;
    if(!isWall(player.x, player.y + my)) player.y += my;

    pickups = pickups.filter(p => {
        if(Math.hypot(player.x-p.x, player.y-p.y) < 35) {
            if(p.type === 'ammo') player.ammo += 20;
            if(p.type === 'hp') player.health = Math.min(100, player.health+25);
            if(p.type === 'berserk') player.berserk = 500;
            return false;
        }
        drawFlippedSprite(assets[p.type], p.x, p.y + Math.sin(gameTicks*0.1)*3, p.x+1, p.y, 35, 'white', true);
        return true;
    });

    projectiles = projectiles.filter(p => {
        p.x += Math.cos(p.a)*p.s; p.y += Math.sin(p.a)*p.s; p.l--;
        enemies.forEach(e => {
            if(Math.hypot(p.x-e.x, p.y-e.y) < 25) {
                e.hp -= 15; p.l = 0;
                for(let i=0; i<8; i++) bloodSplats.push({x:e.x+(Math.random()-0.5)*15, y:e.y+(Math.random()-0.5)*15, s:Math.random()*5+2, c:'#900'});
            }
        });
        ctx.fillStyle='#ff0'; ctx.beginPath(); ctx.arc(p.x, p.y, 2.5, 0, 7); ctx.fill();
        return p.l > 0 && !isWall(p.x, p.y);
    });

    enemies = enemies.filter(e => {
        let a = Math.atan2(player.y-e.y, player.x-e.x);
        if(!isWall(e.x+Math.cos(a)*2.2, e.y+Math.sin(a)*2.2)) { e.x+=Math.cos(a)*2.2; e.y+=Math.sin(a)*2.2; }
        if(Math.hypot(e.x-player.x, e.y-player.y) < 30) { 
            player.health -= 0.6; 
            document.getElementById('damage-flash').style.display = 'block';
            setTimeout(() => document.getElementById('damage-flash').style.display = 'none', 40);
        }
        if(e.hp <= 0) { killCount++; return false; }
        drawFlippedSprite(assets.enemy, e.x, e.y, player.x, player.y, 50, '#cc0000');
        return true;
    });

    if(muzzleFlash > 0) {
        let pA = Math.atan2(mousePos.y-player.y, mousePos.x-player.x);
        ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(pA);
        ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.arc(35, 0, 10, 0, Math.PI*2); ctx.fill(); 
        ctx.restore(); muzzleFlash--;
    }

    drawFlippedSprite(assets.player, player.x, player.y, mousePos.x, mousePos.y, 60, '#2e7d32');

    if(player.berserk > 0) player.berserk--;
    if(enemies.length === 0) { currentLevel++; spawnLevel(); }
    if(player.health <= 0) location.reload();

    document.getElementById('health').innerText = Math.ceil(player.health);
    document.getElementById('ammo').innerText = player.ammo;
    document.getElementById('kills').innerText = killCount;
    document.getElementById('level-num').innerText = currentLevel;

    ctx.restore(); requestAnimationFrame(loop);
}

let isRadioMode = false;
function playTrack() {
    if(!isRadioMode) return;
    let n = Math.floor(Math.random()*8)+1;
    bgMusic.src = `audio/track${n}.mp3`;
    bgMusic.play().then(() => {
        document.getElementById('track-title').innerText = trackNames[n];
        document.getElementById('now-playing').classList.add('show');
        setTimeout(() => document.getElementById('now-playing').classList.remove('show'), 4000);
    }).catch(e => {});
}
bgMusic.onended = playTrack;
document.getElementById('skip-btn').onclick = playTrack;
document.querySelectorAll('input[name="track"]').forEach(r => r.onchange = e => { 
    isRadioMode = (e.target.value==='radio'); if(isRadioMode) playTrack(); else bgMusic.pause(); 
});

window.addEventListener('keydown', e => {
    if(e.key.toLowerCase() === 'p' || e.key === 'Escape') togglePause();
    keys[e.key.toLowerCase()] = true;
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
window.addEventListener('mousemove', e => { mousePos.x = e.clientX; mousePos.y = e.clientY; });
window.addEventListener('mousedown', () => {
    if(isPaused || player.ammo <= 0 || !gameStarted) return;
    const now = Date.now();
    if(now - player.lastShot < (player.berserk > 0 ? 200 : 750)) return;
    player.lastShot = now;
    player.ammo--; screenShake = 12; muzzleFlash = 3;
    shells.push({x: player.x, y: player.y, r: Math.random()*7});
    let baseAngle = Math.atan2(mousePos.y-player.y, mousePos.x-player.x);
    for(let i=0; i<10; i++) projectiles.push({x:player.x, y:player.y, a:baseAngle+(Math.random()-0.5)*0.4, s:18+Math.random()*5, l:45});
});
</script>
</body>
</html>